from sage.rings.fast_arith import prime_range
from Crypto.Util.number import long_to_bytes,bytes_to_long
import owiener
import sympy
from os import urandom

#random number that is 3 bytes long, to optimize the search for the modulus N
Rand = bytes_to_long(urandom(3))
#Produces about 10 possible Modulus numbers to work with instead of 256, in this case

Primes= sage.rings.fast_arith.prime_range(1,Rand)



print('length of PrimeList = '+str(len(Primes)))

r=8

PKEY = 14192646310719975031517528381795548241077678859071194396837281472399230674325587198691913743313024193030641258581477544395982020385534616950314446352119543012689979705497443206671093873748633162188213109347667494028713308821945628880987033909436936504594085029207071182583896573425433818693447573712242776054326253393149643818428222532313129014785625379928796322492111783102063504659053965652092334907431265629283336869752591405010801363428649651892548988084920295512198406822149854508798413366425646089176325412867633899847841343293434518769693835679828109184625256833518392375615524221729773443578746961887429674099018040291053535429314874943299587513900900515776980848746070077651676814430155460898107362207677739452859298842563030631706907437662807884529549746843462830493900480079096937402325307522965877069080418178692616875205678928420840955518031258855869218152431304423803589723140983606576549207164114711076498723237274262054605174412193097533550076687418481230734706280737017543741247718967059747548710091320650704988384742281590019869955579949961574733610565593105027342454880292474482792325237942870408329807427182014062811782475262070063065860763705715879581562335668163076088547827008755841277828137570366416095778

n = bytes_to_long(long_to_bytes(PKEY)[ : - (16 - r) // 8 ]) << 8
e= bytes_to_long(long_to_bytes(PKEY)[- (16 - r) // 8 : ]) << 8

enc = 93313196155732054514477836642637636744872135106456047659057794344503071105783322399713135615723000054324693644981340568454628360027598469597864407205974007198804288563284521413279406211756674451582156555173212403946908121125010635246043311803494356106191509999360722019559999844621905376368824621365540442906142224342650371557766313381899279520110833822291649001754956653102495882094754863493058001964760438040783400782352466943990226083197340594364084294954324101604417550048379969516185353765224920719355485680872367930581872987972421836853197205534334204586713387469939986387582911728909524428102693874671302382*pow(2,8)


LN=[]
List_D_N_E=[]

for i in range(n,n+256):

    if sympy.isprime(i):
        continue

    C=True

    for j in Primes:

        if (i%j)==0:
            C=False
            break

    if(C):
        LN.append(i)

print('length LN='+str(len(LN)))
print('Finding small private key using wiener attack')

for i in range(e,e+256):

    print('Step : ' + str(i-e) + ' / 256')

    if sympy.isprime(i):
        LE.append(i)

    for j in LN:
        d = owiener.attack(i, j)
        #print(d)

        if d!=None:
            List_D_N_E.append([d,j,i])


print('Length LN = '+str(len(LN)))
print('Length List_D_N_E = '+str(len(List_D_N_E)))
print('List_D_N_E : '+str(List_D_N_E))


for D in List_D_N_E:

    for j in range(enc,enc+256):
        p=pow(j,D[0],D[1])

        try:

            print('Decrypted Flag : {' + long_to_bytes(p).decode() + '}')
            print('Encrypted Flag : ' + str(long_to_bytes(j)))

        except:

            None
